import { useGetObservations } from '@plentyag/app-devices/src/common/hooks';
import { Device } from '@plentyag/app-devices/src/common/types';
import { getDeviceRequestPath } from '@plentyag/app-devices/src/common/utils';
import {
  Card,
  dataTestIdsDialogConfirmation,
  DialogConfirmation,
  Dropdown,
  DropdownItem,
  DropdownItemText,
  useGlobalSnackbar,
} from '@plentyag/brand-ui/src/components';
import { Grid } from '@plentyag/brand-ui/src/material-ui/core';
import { useCoreStore } from '@plentyag/core/src/core-store';
import { usePostRequest } from '@plentyag/core/src/hooks';
import { NormalizedObservation } from '@plentyag/core/src/types';
import {
  getExecutiveServiceRequestUrl,
  getExecutiveServiceSubmitterHeaders,
  parseErrorMessage,
} from '@plentyag/core/src/utils';
import { DateTime } from 'luxon';
import React from 'react';
import { useHarmonicIntervalFn } from 'react-use';

import { dataTestIdsTableFaults, TableFaults } from './components';
import { getFaultsToClear } from './utils';

export const CLEAR_LUMINAIRE_FAULTS_SUCCESS_MESSAGE = 'Luminaire Faults successfully cleared';
export const NO_FAULTS_MESSAGE = 'No Faults received in the last minute';

const DELAY = 5000 * 60; // 5 minutes

const dataTestIds = {
  root: 'tab-panel-device-faults-root',
  cardAction: 'tab-panel-device-faults-card-action',
  clearLuminaireFaults: 'tab-panel-device-faults-clear-luminaire-faults',
  dialogConfirmation: dataTestIdsDialogConfirmation.root,
  confirm: dataTestIdsDialogConfirmation.confirm,
  cancelConfirmation: dataTestIdsDialogConfirmation.cancel,
  tableFaults: dataTestIdsTableFaults.root,
  tableRow: dataTestIdsTableFaults.tableRow,
};

export { dataTestIds as dataTestIdsTabPanelDeviceFaults };

export interface TabPanelDeviceFaults {
  device: Device;
  delay?: number;
}

/**
 * Context: Hathor devices sends two types of faults that we store as Observations in OI.
 *
 * # HathorFaultDetected
 *   - Interlocking: is represented by an Observation with an attribute "requestToEnter=true".
 *     This type of fault has a distinct column in the TableFaults component.
 *   - Overcurrent: is represented by an Observation with an attribute "overcurrent1=true"
 *   - Overtemperature: is represented by an Observation with an attribute "overtemp1=true"
 *
 * From the frontend POV, we just list these Observations as they are and show their attributes in a modal.
 * This type of fault can be cleared by the user, by sending a request to ES.
 *
 * # FaultEvent: One of fault event generated by Hathor.
 *   Current fault events are of type:
 *   - LuminaireOverCurrentFaultEvent
 *   - LuminaireOverTemperatureFaultEvent
 *
 * # SprinkleFaultDetected: correspond to temperature reading out of range.
 *   This fault is sent by the sprinkles device dunring temperature readings, (e.g every minute).
 *
 * This type of fault is self clearing, meaning it will get cleared when the temperature is in range again.
 */
export const TabPanelDeviceFaults: React.FC<TabPanelDeviceFaults> = ({ device, delay = DELAY }) => {
  const snackbar = useGlobalSnackbar();
  const [state] = useCoreStore();
  const { makeRequest } = usePostRequest({
    url: getExecutiveServiceRequestUrl(getDeviceRequestPath(device, 'Hathor', 'ClearLuminaireFaults')),
  });
  const [dialogOpen, setDialogOpen] = React.useState<boolean>(false);
  const [from, setFrom] = React.useState(DateTime.now().toUTC().toISO());

  // filter out all the LuminaireOverCurrentFaultEvent and LuminaireOverTemperatureFaultEvent observations when we receive a
  // HathorFaultDetected observation with the value "false" (meaning the user cleared the Luminaire Faults).
  const filterFaultEvents = (observation, index, observations) => {
    if (observations.length == 0) {
      return true;
    }
    const hathorFaultObservation = observations[0];
    // get the timestamp when luminaire fault events were cleared
    let luminareClearTime;
    if (
      hathorFaultObservation.observationName === 'HathorFaultDetected' &&
      hathorFaultObservation.valueString === 'false'
    ) {
      luminareClearTime = DateTime.fromSQL(hathorFaultObservation.observedAt, { zone: 'utc' }).toJSDate();
    }

    if (
      luminareClearTime &&
      (observation.observationName === 'LuminaireOverCurrentFaultEvent' ||
        observation.observationName === 'LuminaireOverTemperatureFaultEvent')
    ) {
      // filter out these observations if observedAt before luminaire clear faults observedAt
      const faultObservationTime = DateTime.fromSQL(observation.observedAt, { zone: 'utc' }).toJSDate();
      if (faultObservationTime.getTime() < luminareClearTime.getTime()) {
        return false;
      }
    }
    return true;
  };

  const requests = {
    hathorFaultsDetected: useGetObservations({
      device,
      observationName: 'HathorFaultDetected',
      amount: -1,
      unit: 'week',
      from,
    }),

    overCurrentFaultEvent: useGetObservations({
      device,
      observationName: 'LuminaireOverCurrentFaultEvent',
      amount: -1,
      unit: 'week',
      from,
    }),

    overTemperatureFaultEvent: useGetObservations({
      device,
      observationName: 'LuminaireOverTemperatureFaultEvent',
      amount: -1,
      unit: 'week',
      from,
    }),

    sprinklesFaultsUpdated: useGetObservations({
      device,
      observationName: 'SprinkleFaultDetected',
      amount: -1,
      unit: 'minute',
      limit: 10,
      from,
    }),
  };

  const isValidating =
    requests.hathorFaultsDetected.isValidating ||
    requests.overCurrentFaultEvent.isValidating ||
    requests.overTemperatureFaultEvent.isValidating ||
    requests.sprinklesFaultsUpdated.isValidating;

  const observations: NormalizedObservation[] = [
    requests.hathorFaultsDetected.data?.data,
    requests.overCurrentFaultEvent.data?.data,
    requests.overTemperatureFaultEvent.data?.data,
    requests.sprinklesFaultsUpdated.data?.data,
  ]
    .filter(Boolean)
    .flat()
    .filter(filterFaultEvents);

  const hasLuminaireFaults =
    requests.hathorFaultsDetected.data?.meta?.total > 0 ||
    requests.overCurrentFaultEvent.data?.meta?.total > 0 ||
    requests.overTemperatureFaultEvent.data?.meta?.total > 0;

  const handleClearLuminaireFaults = () => {
    makeRequest({
      data: {
        ...getExecutiveServiceSubmitterHeaders(state),
        ...getFaultsToClear(requests.hathorFaultsDetected.data?.data[0]),
      },
      onSuccess: () => {
        snackbar.successSnackbar(CLEAR_LUMINAIRE_FAULTS_SUCCESS_MESSAGE);
        setDialogOpen(false);
      },
      onError: error => {
        snackbar.errorSnackbar({ message: parseErrorMessage(error) });
        setDialogOpen(false);
      },
    });
  };

  useHarmonicIntervalFn(() => {
    setFrom(DateTime.now().toUTC().toISO());
  }, delay);

  return (
    <Grid item xs={6}>
      <Card
        data-testid={dataTestIds.root}
        title="Faults"
        fallback={NO_FAULTS_MESSAGE}
        isLoading={isValidating}
        doNotPadContent
        action={
          hasLuminaireFaults && (
            <Dropdown data-testid={dataTestIds.cardAction}>
              <DropdownItem onClick={() => setDialogOpen(true)}>
                <DropdownItemText primary="Clear Luminaire Faults" data-testid={dataTestIds.clearLuminaireFaults} />
              </DropdownItem>
            </Dropdown>
          )
        }
      >
        {observations.length > 0 && (
          <>
            <TableFaults observations={observations} />
            <DialogConfirmation
              open={dialogOpen}
              title="Clear Luminaire Faults?"
              confirmLabel="Yes"
              onConfirm={handleClearLuminaireFaults}
              onCancel={() => setDialogOpen(false)}
            />
          </>
        )}
      </Card>
    </Grid>
  );
};
